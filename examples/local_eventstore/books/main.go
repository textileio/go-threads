package main

import (
	"context"
	"io/ioutil"
	"os"
	"time"

	"github.com/textileio/go-threads/common"
	core "github.com/textileio/go-threads/core/db"
	"github.com/textileio/go-threads/core/thread"
	"github.com/textileio/go-threads/db"
	"github.com/textileio/go-threads/util"
)

type book struct {
	ID     core.InstanceID `json:"_id"`
	Title  string
	Author string
	Meta   bookStats
}

type bookStats struct {
	TotalReads int
	Rating     float64
}

func main() {
	d, clean := createMemDB()
	defer clean()

	collection, err := d.NewCollection(db.CollectionConfig{
		Name:   "Book",
		Schema: util.SchemaFromInstance(&book{}, false),
	})
	checkErr(err)

	// Bootstrap the collection with some books: two from Author1 and one from Author2
	{
		// Create a two books for Author1
		book1 := &book{ // Notice ID will be autogenerated
			Title:  "Title1",
			Author: "Author1",
			Meta:   bookStats{TotalReads: 100, Rating: 3.2},
		}
		book2 := &book{
			Title:  "Title2",
			Author: "Author1",
			Meta:   bookStats{TotalReads: 150, Rating: 4.1},
		}
		_, err := collection.CreateMany([][]byte{util.JSONFromInstance(book1), util.JSONFromInstance(book2)})
		checkErr(err)

		// Create book for Author2
		book3 := &book{
			Title:  "Title3",
			Author: "Author2",
			Meta:   bookStats{TotalReads: 500, Rating: 4.9},
		}
		_, err = collection.Create(util.JSONFromInstance(book3))
		checkErr(err)
	}

	// Query all the books
	{
		books, err := collection.Find(&db.Query{})
		checkErr(err)
		if len(books) != 3 {
			panic("there should be three books")
		}
	}

	// Query the books from Author2
	{
		books, err := collection.Find(db.Where("Author").Eq("Author1"))
		checkErr(err)
		if len(books) != 2 {
			panic("Author1 should have two books")
		}
	}

	// Query with nested condition
	{
		books, err := collection.Find(db.Where("Meta.TotalReads").Eq(float64(100)))
		checkErr(err)
		if len(books) != 1 {
			panic("There should be one book with 100 total reads")
		}
	}

	// Query book by two conditions
	{
		books, err := collection.Find(db.Where("Author").Eq("Author1").And("Title").Eq("Title2"))
		checkErr(err)
		if len(books) != 1 {
			panic("Author1 should have only one book with Title2")
		}
	}

	// Query book by OR condition
	{
		books, err := collection.Find(db.Where("Author").Eq("Author1").Or(db.Where("Author").Eq("Author2")))
		checkErr(err)
		if len(books) != 3 {
			panic("Author1 & Author2 have should have 3 books in total")
		}
	}

	// Sorted query
	{
		// Ascending
		res, err := collection.Find(db.Where("Author").Eq("Author1").OrderBy("Meta.TotalReads"))
		checkErr(err)
		books := make([]*book, len(res))
		for i, item := range res {
			book := &book{}
			util.InstanceFromJSON(item, book)
			books[i] = book
		}
		if books[0].Meta.TotalReads != 100 || books[1].Meta.TotalReads != 150 {
			panic("books aren't ordered asc correctly")
		}
		// Descending
		res, err = collection.Find(db.Where("Author").Eq("Author1").OrderByDesc("Meta.TotalReads"))
		checkErr(err)
		books = make([]*book, len(res))
		for i, item := range res {
			book := &book{}
			util.InstanceFromJSON(item, book)
			books[i] = book
		}
		if books[0].Meta.TotalReads != 150 || books[1].Meta.TotalReads != 100 {
			panic("books aren't ordered desc correctly")
		}
	}

	// Query, Update, and Save
	{
		res, err := collection.Find(db.Where("Title").Eq("Title3"))
		checkErr(err)
		books := make([]*book, len(res))
		for i, item := range res {
			book := &book{}
			util.InstanceFromJSON(item, book)
			books[i] = book
		}

		// Modify title
		firstBook := books[0]
		firstBook.Title = "ModifiedTitle"
		_ = collection.Save(util.JSONFromInstance(firstBook))
		res, err = collection.Find(db.Where("Title").Eq("Title3"))
		checkErr(err)
		if len(res) != 0 {
			panic("Book with Title3 shouldn't exist")
		}

		// Delete it
		res, err = collection.Find(db.Where("Title").Eq("ModifiedTitle"))
		checkErr(err)
		if len(res) != 1 {
			panic("Book with ModifiedTitle should exist")
		}
		books = make([]*book, len(res))
		for i, item := range res {
			book := &book{}
			util.InstanceFromJSON(item, book)
			books[i] = book
		}
		_ = collection.Delete(books[0].ID)
		res, err = collection.Find(db.Where("Title").Eq("ModifiedTitle"))
		checkErr(err)
		if len(res) != 0 {
			panic("Book with ModifiedTitle shouldn't exist")
		}
	}
}

func createMemDB() (*db.DB, func()) {
	dir, err := ioutil.TempDir("", "")
	checkErr(err)
	n, err := common.DefaultNetwork(dir, common.WithNetDebug(true), common.WithNetHostAddr(util.FreeLocalAddr()))
	checkErr(err)
	id := thread.NewIDV1(thread.Raw, 32)
	d, err := db.NewDB(context.Background(), n, id, db.WithNewRepoPath(dir))
	checkErr(err)
	return d, func() {
		time.Sleep(time.Second) // Give threads a chance to finish work
		if err := n.Close(); err != nil {
			panic(err)
		}
		_ = os.RemoveAll(dir)
	}
}

func checkErr(err error) {
	if err != nil {
		panic(err)
	}
}
